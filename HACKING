CUSTOMISING AND EXTENDING SOLILOQUY
===================================
Language Information
--------------------
Introduction
~~~~~~~~~~~~
Soliloquy is written in what is essentially C99, but is extended somewhat to
give C some Lisp-like features. This is done by both the preprocessor and an
external tool (run automatically). Due to the complex and dynamic nature of the
provided programming facilities, automatic garbage collection is uesd. See
common.h.

All implementation files *must* begin with
----------------
  #include "foo.slc"
----------------
where "foo" is the base name of the file. The .slc file contains auto-generated
implementations of language extensions and declarations for
symbols. Additionally, it includes the header for your implementation (if there
is one), <config.h> if appropriate, as well as "common.h".

Symbols (General)
~~~~~~~~~~~~~~~~~
The first extension of note are symbols. Symbols, which are only valid in
implementation files (*.c), look like undeclared variables beginning with
one or two `$'s, followed by a name using Hungarian notation.

A symbol may be either private (one $) or public (two $s). Private symbols are
unique to each compilation unit, whereas public symbols are shared across all.
The letters of a symbol's name between the dollars and the first underscore
identify its type. Supported types are (* = non-first-class):
  i     integer (type signed or unsigned)
  s     string (type const char*)
  h     hook point (undefined type)
  f*    function to call the corresponding hook (type void (void))
  lT    list of type T (may be multidimenional) (type list_T)
  aT    dynamic array of type T (type dynar_T)
  u*    unique identifier (a pointer to itself, simply to indicate identity)
  v     reference to unique identifier (type identity)
  p     untyped pointer (type void*)
  d*    symbol domain (discussed below) (typeless)
  o     object (type object)

Besides simply being implicit global variables, symbols form the basis of
Soliloquy's "eviscerated object" system. Any first-class symbol may be
_implanted_ into an object. Implantation makes the value stored in the symbol
dependant on the current context; when an object a symbol is implanted in is
activated ("eviscerated"), the symbols value is changed to that stored in the
object; correspondingly, when the object is deactivated ("re-emboweled"), the
old value of the symbol is restored.

Symbols: Hook Points
~~~~~~~~~~~~~~~~~~~~
Hook points are implicit collections of functions to run, usable as both
methods and proper hooks (akin to in Emacs). Each hook point has a collection
of functions to run, divided into three priorities: BEFORE, MAIN, and
AFTER. Functions in the BEFORE priority are intended to examine, intercept
and/or modify the input parameters to the hook; those in MAIN should perform
the intended work of the hook; and those in AFTER are intended to do things
with the return value. Since hook functions neither take arguments nor have
return values, parameters and result data are instead passed via symbols.

Within each hook point priority, each hook may define before or after
constraints against other hook identities; such constraints guarantee relative
execution order between the hooks. (Do NOT create a hook that defines itself to
be "before (or after) everything" --- it will break the program if two hooks do
this. Instead, take advantages of hook classes to accomplish this.)

If a $f symbol is ever referenced, its corresponding $h exists implictly; by
simply calling $f symbols at logical points in code, you can easily add
extension points.

Symbols: Symbol Domains
~~~~~~~~~~~~~~~~~~~~~~~
Symbol domains are non-first-class symbols whose purpose is to group symbols
which are typically implanted in groups. Any symbol whose base name (ie, in
"$i_foo", "foo" is the base name) begins with the base name of a symbol domain
followed by an underscore is implicitly part of that domain. Public symbol
domains capture only public symbols, and private symbol domains only capture
private symbols.

When a domain is to be implanted into an object, all symbols which are members
thereof are implanted into that object. Domains may be subdomains of other
domains, which has the expected effect.

It is also possible to manually add members to domains (see member_of_domain in
common.h); using this facility to make a cycle of subdomains has undefined
effects. Due to the implicit behaviour of symbol domains (especially public),
recommended convention is to capitalise the first letter of each word in the
domain (eg, $d_This_Is_A_Domain).
