CUSTOMISING AND EXTENDING SOLILOQUY
===================================
Language Information
--------------------
Introduction
~~~~~~~~~~~~
Soliloquy is written in what is essentially C99, but is extended somewhat to
give C some Lisp-like features. This is done by both the preprocessor and an
external tool (run automatically). Due to the complex and dynamic nature of the
provided programming facilities, automatic garbage collection is uesd. See
common.h.

All implementation files *must* begin with
----------------
  #include "foo.slc"
----------------
where "foo" is the base name of the file. The .slc file contains auto-generated
implementations of language extensions and declarations for
symbols. Additionally, it includes the header for your implementation (if there
is one), <config.h> if appropriate, as well as "common.h".

Symbols (General)
~~~~~~~~~~~~~~~~~
The first extension of note are symbols. Symbols, which are only valid in
implementation files (*.c), look like undeclared variables beginning with
one or two `$'s, followed by a name using Hungarian notation.

A symbol may be either public (one $) or private (two $s). Private symbols are
unique to each compilation unit, whereas public symbols are shared across all.
The letters of a symbol's name between the dollars and the first underscore
identify its type. Supported types are (* = non-first-class):
  F*    method call (macro)
  H     abstract hook point (type struct hook_point*)
  M*    abstract method call (macro)
  Q     mutable qstring (type qchar*; aka mqstring)
  S     mutable string (type char*; aka mstring)
  W     mutable wstring (type wchar_t*; aka wstring)
  aT    dynamic array of type T (type dynar_T)
  c*    class (macro)
  d*    symbol domain (discussed below) (typeless)
  f*    function to call the corresponding hook (type void (void))
  h     hook point (type struct hook_point)
  i     integer (type signed or unsigned)
  lT    list of type T (may be multidimenional) (type list_T)
  m*    abstract method (type void (void))
  o     object (type object)
  p     untyped pointer (type void*)
  q     qstring (type const qchar*; aka qstring)
  s     string (type const char*; aka string)
  u*    unique identifier (a pointer to itself, simply to indicate identity)
  v     reference to unique identifier (type identity)
  w     wstring (type const wchar_t*; aka wstring)
  y     boolean (type bool)

Besides simply being implicit global variables, symbols form the basis of
Soliloquy's "eviscerated object" system. Any first-class symbol may be
_implanted_ into an object. Implantation makes the value stored in the symbol
dependant on the current context; when an object a symbol is implanted in is
activated ("eviscerated"), the symbols value is changed to that stored in the
object; correspondingly, when the object is deactivated ("re-emboweled"), the
old value of the symbol is restored.

Symbols: Hook Points
~~~~~~~~~~~~~~~~~~~~
Hook points are implicit collections of functions to run, usable as both
methods and proper hooks (akin to in Emacs). Each hook point has a collection
of functions to run, divided into three priorities: BEFORE, MAIN, and
AFTER. Functions in the BEFORE priority are intended to examine, intercept
and/or modify the input parameters to the hook; those in MAIN should perform
the intended work of the hook; and those in AFTER are intended to do things
with the return value. Since hook functions neither take arguments nor have
return values, parameters and result data are instead passed via symbols.

Within each hook point priority, each hook may define before or after
constraints against other hook identities; such constraints guarantee relative
execution order between the hooks. (Do NOT create a hook that defines itself to
be "before (or after) everything" --- it will break the program if two hooks do
this. Instead, take advantages of hook classes to accomplish this.)

If a $f symbol is ever referenced, its corresponding $h exists implictly; by
simply calling $f symbols at logical points in code, you can easily add
extension points.

The advise, advise_before, and advise_after macros allow defining a function
inline to bind to a hook in the root context, assuming you need no special
ordering.

Symbols: Symbol Domains
~~~~~~~~~~~~~~~~~~~~~~~
Symbol domains are non-first-class symbols whose purpose is to group symbols
which are typically implanted in groups. Any symbol whose base name (ie, in
"$i_foo", "foo" is the base name) begins with the base name of a symbol domain
followed by an underscore is implicitly part of that domain. Public symbol
domains capture only public symbols, and private symbol domains only capture
private symbols.

When a domain is to be implanted into an object, all symbols which are members
thereof are implanted into that object. Domains may be subdomains of other
domains, which has the expected effect.

It is also possible to manually add members to domains (see member_of_domain in
common.h); using this facility to make a cycle of subdomains has undefined
effects. Due to the implicit behaviour of symbol domains (especially public),
recommended convention is to capitalise the first letter of each word in the
domain (eg, $d_This_Is_A_Domain).

Symbols: Classes and Methods
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
A class ($c) symbol is a convenience for ad-hoc object-orientation. It implies
$f (and, correspondingly, $h), $d, $u, and $o symbols of the same name.
Furthermore, it itself is a macro for constructing that class. Given a call of
  $c_Foo(...)
the following happens:
- A new object is allocated.
- Within the context of that object:
  - $d_Foo, $h_Foo, and $o_Foo are implanted
  - $o_Foo is set to the new object
  - The contents of ... are executed
  - $f_Foo() is invoked
- The new object is returned (ie, the macro functions as an expression).

The subclass() macro can be used to create subclass-like relations between
classes. (Note that the concept of a "class" is not just the $c symbol itself,
but rather the symbols it implies, including the members of its domain.)

A method ($F) symbol, like a class symbol, is a convenience for a common
object-oriented pattern. It implies $f and $h symbols of the same name. Given a
call of
  $F_Foo_do_something(ret, object, ...)
the following happens:
- Within the context of object:
  - ... is evaluated
  - $f_Foo_do_something() is invoked
  - ret is evaluated, and its result stored
- The result is that of ret, copied outside of the context of object

Abstract methods ($m) and their invocations ($M) provide further abstraction
over normal methods by adding another level of indirection to the hook
points. An $H symbol is merely a pointer to another $h. $m and $M work like $f
and $F, but instead affect the what the corresponding $H points to.

Abstract methods should be named only based on what they do and should
generally be global, eg
  $M_print(0, printer, $s_Printer_line = "Hello, world!");
The existence of a method is inferred by the existence of a hook point of the
name format
  $h_CLASS_NAME
where CLASS names a $c symbol of the same public/private status, and NAME names
a public method. In such cases, a BEFORE hook will be added to $f_CLASS which
runs after $u_superconstructor and assigns $H_NAME to $h_CLASS_NAME (after
implanting it).

Information Structure
---------------------
A Soliloquy instance has zero or more connected Terminals (see terminal.c);
each Terminal determines grid size and how to translate logical formatting into
what works on the terminal.

There are one or more Workspaces; each workspace is bound to a
WorkspaceBacking, and maintains a single EchoArea.

A WorkspaceBacking maintains an array of RenderedLines; a RenderedLine is a
line of text with calculated formatting and metadata, and which is not longer
than the current column width ($i_column_width).

One View exists for every Terminal/Workspace combination. A View maintains a
cut-point, which represents the bottom of the area of the WorkspaceBacking to
display, as well as the location of the cut-point on the Terminal. Each
Terminal has a current View.

A Clip refers to a WorkspaceBacking, Buffer, or other object, and displays it
(or a portion thereof) into a fixed number of RenderedLines.

Clips may be pinned to Workspaces or Terminals. A Clip pinned to a Workspace
shows up only in that Workspace, but on all terminals whose current View refers
to that Workspace; a Clip pinned to a Terminal shows up only on that Terminal,
but across all Views on that Terminal.

