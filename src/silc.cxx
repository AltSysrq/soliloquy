/*
  Copyright â“’ 2012 Jason Lingle

  This file is part of Soliloquy.

  Soliloquy is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  Soliloquy is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with Soliloquy.  If not, see <http://www.gnu.org/licenses/>.
*/
#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

/*
  This is the Silc code generator for Soliloquy symbols. It is only intended to
  be used implicitly by the Makefile.

  If given a file basename on the command-line, it operates in local mode,
  reading from FILE.c and writing to FILE.slc. If given more than one, it
  operates in global mode, reading all listed files (*with* their extensions)
  and writing to symbols.def.
*/

#include <string>
#include <iostream>
#include <fstream>
#include <cstring>
#include <cstdlib>
#include <set>
#include <vector>
#include <cstdarg>
#include <cerrno>
#include <cctype>
#include <list>
#include <map>
using namespace std;

static bool global_mode;

static set<string> symbols_processed, templates_instantiated;
static ofstream out;

static string current_file;
static unsigned line_number;

static int exit_status = 0;

static void process_file(const string&);
static void process_symbol(const string&);
static void domain_membership(void);
static void method_membership(void);
int main(int argc, const char*const* argv) {
  global_mode = (argc != 2);

  if (global_mode) {
    out.open("symbols.def");
    if (!out) {
      perror("ofstream");
      return 1;
    }

    for (int i = 1; i < argc; ++i)
      process_file(string(argv[i]));
  } else {
    string basename = argv[1];
    out.open((basename + ".slc").c_str());
    if (!out) {
      perror("ofstream");
      return 1;
    }

    out << "/**\n * Autogenerated by silc.\n * Do not edit.\n"
        << " * Not intended for human consumption.\n */\n"
        << "#include <common.h>\n";
    // Quick-and-dirty test-for-existence in C++03
    if (ifstream((basename + ".h").c_str()))
      out << "#include \"" << basename << ".h\"\n";

    process_file(basename + ".c");
  }

  // Some implicit symbols
  current_file="<<IMPLICIT>>";
  line_number=0;
  process_symbol("$$u_superconstructor");
  process_symbol("$$u_method_setup");

  //Post-processing tasks dealing with inter-symbol relations
  method_membership();
  domain_membership();

  return exit_status;
}

static void process_line(const string&);
static void process_file(const string& infile) {
  ifstream in(infile.c_str());
  if (!in) {
    perror("ifstream");
    exit(1);
  }

  current_file = infile;
  line_number = 0;

  string line;
  while (getline(in, line)) {
    ++line_number;
    process_line(line);
  }
}

static void process_symbol_starting_at(unsigned&, const string&);
static void process_line(const string& line) {
  for (unsigned i = 0; i+4 <= line.size(); ++i) {
    if (line[i] == '$' &&
        (isalnum(line[i+1]) ||
         (line[i+1] == '$' && isalnum(line[i+2])))) {
      process_symbol_starting_at(i, line);
      --i;
    }
  }
}

static void process_symbol(const string&);
static void process_symbol_starting_at(unsigned& ix, const string& line) {
  unsigned begin = ix;

  // Init state: We already know there is a $ at the beginning
  ++ix;
  // Possible second dollar
  if (line[ix] == '$') ++ix;
  // Type (alnum), should have been verified to be at least one by caller
  do { ++ix; } while (ix < line.size() && isalnum(line[ix]));

  // Underscore after type
  if (ix >= line.size() || line[ix] != '_') {
    cerr << current_file << ':' << line_number << ':'
         << ix << "--" << ix << ": Invalid symbol name (forgot type?)"
         << endl;
    exit_status = 1;
    return;
  }
  ++ix;
  // At least one character basename
  if (ix >= line.size() || !isalnum(line[ix])) {
    cerr << current_file << ':' << line_number << ':'
         << ix << "--" << ix << ": Symbol names must begin with alphanumeric"
         << endl;
    return;
  }

  // Don't care about the rest of the symbol
  while (ix < line.size() && (isalnum(line[ix]) || line[ix] == '_'))
    ++ix;

  process_symbol(line.substr(begin, ix-begin));
}

static bool symbol_is_global(const string& sym) {
  return sym[1] == '$';
}

static string symbol_get_type(const string& sym) {
  unsigned start = symbol_is_global(sym)? 2 : 1;
  return sym.substr(start, sym.find('_')-start);
}

static bool is_first_class(const string& sym) {
  string type(symbol_get_type(sym));
  return
    type != "F" && type != "M" && type != "c" &&
    type != "d" && type != "f" && type != "m" &&
    type != "u";
}

static string symbol_base_name(const string& sym) {
  return sym.substr(sym.find('_')+1);
}

// Extern since there's no way to predeclare a static variable
extern const map<char, void (*)(const string&)> symbol_processors;

static void process_symbol(const string& sym) {
  // Do nothing if we already handled this symbol, or it is a non-public
  // variable in global mode.
  if (symbols_processed.count(sym) ||
      (!symbol_is_global(sym) && global_mode))
    return;
  symbols_processed.insert(sym);
  
  string type(symbol_get_type(sym));
  map<char, void (*)(const string&)>::const_iterator it =
    symbol_processors.find(type[0]);

  if (it == symbol_processors.end()) {
    cerr << current_file << ':' << line_number
         << ": Unknown symbol type: " << type
         << ", in symbol: " << sym << endl;
    exit_status = 1;
    return;
  }

  it->second(sym);
}

static void process_first_class(const string&);
static void process_function_macro(const string&);
static void process_class(const string&);
static void process_symbol_domain(const string&);
static void process_function(const string&);
static void process_unique_identity(const string&);

#define p(x,y) pair<char, void (*)(const string&)>(x,y)
static const pair<char, void (*)(const string&)> symbol_processors_[] = {
  p('F', process_function_macro),
  p('H', process_first_class),
  p('M', process_function_macro),
  p('a', process_first_class),
  p('c', process_class),
  p('d', process_symbol_domain),
  p('f', process_function),
  p('h', process_first_class),
  p('i', process_first_class),
  p('l', process_first_class),
  p('m', process_function),
  p('o', process_first_class),
  p('p', process_first_class),
  p('s', process_first_class),
  p('u', process_unique_identity),
  p('v', process_first_class),
};
const map<char, void (*)(const string&)> symbol_processors(
  symbol_processors_,
  symbol_processors_ + sizeof(symbol_processors_)/sizeof(symbol_processors_[0])
);

static bool get_ctype_of_type(string&,
                              const string& symbol, const string& type);
static bool instantiate_templates(const string& symbol, const string& type);
static string change_symbol_type_char(const string& symbol, char newtype);

static void format(const string& templait, ...);

static void process_first_class(const string& symbol) {
  string type(symbol_get_type(symbol));
  string ctype;
  if (!get_ctype_of_type(ctype, symbol, type)) return;
  if (!instantiate_templates(symbol, type)) return;

  const char* linkage = symbol_is_global(symbol)? "" : "static";

  if (symbol_is_global(symbol) == global_mode) {
    //Declare and define
    format("`LINKAGE struct symbol_header _`SYM_base;\n"
           "`LINKAGE typeof(`CTYPE) _`SYM;\n"
           "ATSTART(ANONYMOUS_SLC, SYMBOL_CONSTRUCTION_PRIORITY) {\n"
           "  _`SYM_base.size = sizeof(`CTYPE);\n"
           "  _`SYM_base.payload = &_`SYM;\n"
           "}\n"
           "ATSTART(ANONYMOUS_SLC, SYMBOL_ROOT_IMPLANTATION_PRIORITY) {\n"
           "  object_implant(&_`SYM_base, ImplantSingle);\n"
           "}\n",
           "`LINKAGE", linkage, "`SYM", symbol.c_str(),
           "`CTYPE", ctype.c_str(), NULL);
    //Only write implantation type if non-global (it won't be needed if it is a
    //global declaration (and would conflict if common.c needed it))
    if (!symbol_is_global(symbol))
      format("static const enum implantation_type\n"
             "    _`SYM_implantation_type = ImplantSingle;\n",
             "`SYM", symbol.c_str(), NULL);
  } else {
    //Declare only
    format("extern struct symbol_header _`SYM_base;\n"
           "extern typeof(`CTYPE) _`SYM;\n"
           "static const enum implantation_type _`SYM_implantation_type =\n"
           "    ImplantSingle;\n",
           "`SYM", symbol.c_str(), "`CTYPE", ctype.c_str(), NULL);
  }

  format("#define `SYM _`SYM\n",
         "`SYM", symbol.c_str(), NULL);
}

static void process_function_macro(const string& symF) {
  //Preprocessor definition, only needed in private mode
  if (global_mode) return;

  string symf;
  string type(symbol_get_type(symF));
  if (type == "F") {
    symf = change_symbol_type_char(symF, 'f');
  } else {
    symf = change_symbol_type_char(symF, 'm');
  }
  process_symbol(symf);

  format("#define `SYMF(ret, this, ...) ({\\\n"
         "  typeof(ret) _Fsym_ret;        \\\n"
         "  within_context((this), {      \\\n"
         "    __VA_ARGS__;                \\\n"
         "    `SYMf();                    \\\n"
         "    _Fsym_ret = (ret);          \\\n"
         "  });                           \\\n"
         "  _Fsym_ret; })                   \n",
         "`SYMF", symF.c_str(), "`SYMf", symf.c_str(), NULL);
}

static void process_class(const string& csym) {
  if (global_mode) return; //Only a preprocessor definition, nothing to do globally
  
  string fsym, osym, usym, dsym, hsym;
  fsym = change_symbol_type_char(csym, 'f');
  osym = change_symbol_type_char(csym, 'o');
  usym = change_symbol_type_char(csym, 'u');
  dsym = change_symbol_type_char(csym, 'd');
  hsym = change_symbol_type_char(csym, 'h');
  process_symbol(fsym);
  process_symbol(osym);
  process_symbol(usym);
  process_symbol(dsym);
  process_symbol(hsym);
  format("#define `CSYM(...) ({                                          \\\n"
         "  object _csym_this = object_new(NULL);                        \\\n"
         "  within_context(_csym_this, {                                 \\\n"
         "    implant(`OSYM); implant(`DSYM); implant(`HSYM);            \\\n"
         "    `OSYM = _csym_this;                                        \\\n"
         "    __VA_ARGS__;                                               \\\n"
         "    `FSYM();                                                   \\\n"
         "  });                                                          \\\n"
         "  _csym_this; })                                                 \n"
         "#define `CSYM_domain `DSYM                                       \n"
         "#define `CSYM_function `FSYM                                     \n"
         "#define `CSYM_identity `USYM                                     \n",
         "`CSYM", csym.c_str(), "`OSYM", osym.c_str(),
         "`USYM", usym.c_str(), "`DSYM", dsym.c_str(),
         "`HSYM", hsym.c_str(), "`FSYM", fsym.c_str(), NULL);
}

static void process_function(const string& sym) {
  if (symbol_is_global(sym) == global_mode) {
    // Definition and declaration
    string hsym(change_symbol_type_char(sym,
                                        symbol_get_type(sym) == "f"?
                                        'h' : 'H'));
    process_symbol(hsym);
    const char* linkage = symbol_is_global(sym)? "" : "static";
    format("`LINKAGE void _`SYM(void) {                \n"
           "  invoke_hook(`REF`HOOK);                  \n"
           "}                                          \n",
           "`LINKAGE", linkage, "`SYM", sym.c_str(),
           "`REF", (symbol_get_type(sym) == "f"? "&" : ""),
           "`HOOK", hsym.c_str(),
           NULL);
  } else {
    // Declaration only
    format("extern void _`SYM(void);\n",
           "`SYM", sym.c_str(), NULL);
  }

  format("#define `SYM _`SYM\n",
         "`SYM", sym.c_str(), NULL);
}

static void process_unique_identity(const string& sym) {
  if (symbol_is_global(sym) == global_mode) {
    //Declaration and definition
    const char* linkage = symbol_is_global(sym)? "" : "static";
    format("`LINKAGE const identity _`SYM = (identity)&_`SYM;\n",
           "`LINKAGE", linkage, "`SYM", sym.c_str(), NULL);
  } else {
    //Declaration only
    format("extern const identity _`SYM;\n",
           "`SYM", sym.c_str(), NULL);
  }

  format("#define `SYM _`SYM\n",
         "`SYM", sym.c_str(), NULL);
}

static void process_symbol_domain(const string& sym) {
  if (symbol_is_global(sym) == global_mode) {
    //Declaration and definition
    const char* linkage = symbol_is_global(sym)? "" : "static";
    format("`LINKAGE struct symbol_header _`SYM_base;                \n"
           "`LINKAGE struct symbol_domain* _`SYM = NULL;             \n"
           "ATSTART(ANONYMOUS_SLC, SYMBOL_CONSTRUCTION_PRIORITY) {   \n"
           "  _`SYM_base.size = sizeof(struct symbol_domain*);       \n"
           "  _`SYM_base.payload = &_`SYM;                           \n"
           "}                                                        \n",
           "`LINKAGE", linkage, "`SYM", sym.c_str(), NULL);
  } else {
    format("extern struct symbol_header _`SYM_base;                  \n"
           "extern struct symbol_domain* _`SYM;                      \n",
           "`SYM", sym.c_str(), NULL);
  }

  if (!global_mode)
    format("static const enum implantation_type _`SYM_implantation_type = \n"
           "    ImplantDomain;\n",
           "`SYM", sym.c_str(), NULL);

  format("#define `SYM _`SYM\n",
         "`SYM", sym.c_str(), NULL);
}

static bool get_ctype_of_type(string& ctype,
                              const string& symbol, const string& type) {
  if (type.empty()) {
    cerr << current_file << ':' << line_number
         << ": Empty type encountered processing symbol: " << symbol << endl
         << current_file << ':' << line_number
         << ": You probably forgot to specify a template type "
         << current_file << ':' << line_number
         << ": (eg, $l_foo is not ok, you must say what is in the list, eg, $ls_foo)"
         << endl;
    exit_status = 1;
    return false;
  }

  switch (type[0]) {
  case 'H':
    ctype = "struct hook_point*";
    break;

  case 'a':
    ctype = string("dynar_") + type.substr(1);
    break;

  case 'l':
    ctype = string("list_") + type.substr(1);
    break;

  case 'i':
    ctype = "int";
    break;

  case 's':
    ctype = "string";
    break;

  case 'h':
    ctype = "struct hook_point";
    break;

  case 'v':
    ctype = "identity";
    break;

  case 'p':
    ctype = "void*";
    break;

  case 'o':
    ctype = "object";
    break;

  default:
    cerr << current_file << ':' << line_number
         << ": Unrecognised or non-first-class type: " << type << endl
         << current_file << ':' << line_number
         << ": While processing symbol: " << symbol << endl;
    return false;
  }

  return true;
}

static bool instantiate_templates(const string& symbol, const string& type) {
  if (type.empty()) return true;
  if (templates_instantiated.count(type)) return true;
  templates_instantiated.insert(type);

  static bool has_loaded = false;
  static string list_template, dynar_template;
  if (!has_loaded) {
    has_loaded = true;
    {
      ifstream in("list.plt");
      if (!in) {
        perror("ifstream(list.plt)");
        exit(255);
      }

      getline(in, list_template, '\0');
    }

    {
      ifstream in("dynar.plt");
      if (!in) {
        perror("ifstream(dynar.plt)");
        exit(255);
      }

      getline(in, dynar_template, '\0');
    }
  }

  string sub = type.substr(1);

  if (type[0] == 'l' || type[0] == 'a') {
    string ctype;
    if (!get_ctype_of_type(ctype, symbol, sub)) return false;
    if (!instantiate_templates(symbol, sub)) return false;

    format(type[0] == 'l'? list_template : dynar_template,
           "CTYPE", ctype.c_str(), "HUNG", sub.c_str(), NULL);
  }

  return true;
}

static string change_symbol_type_char(const string& symbol, char type) {
  string ret(symbol);
  ret[symbol_is_global(ret)? 2 : 1] = type;
  return ret;
}

static void format(const string& templait, ...) {
  string output(templait);
  
  va_list args;
  va_start(args, templait);

  const char* from, * to;
  while ((from = va_arg(args, const char*))) {
    to = va_arg(args, const char*);

    size_t where;
    while (string::npos != (where = output.find(from)))
      output.replace(where, strlen(from), to);
  }
  
  va_end(args);

  out << output;
}

static void domain_membership(void) {
  set<string> orphans(symbols_processed);
  // Iterate through the processed symbols in reverse order (longer, more
  // specific domains will come first).
  for (set<string>::reverse_iterator it = symbols_processed.rbegin();
       it != symbols_processed.rend(); ++it) {
    if (symbol_is_global(*it) == global_mode && symbol_get_type(*it) == "d") {
      string dom(string("_") + symbol_base_name(*it) + "_");
      // Since for some reason the C++03 API doesn't have set::erase() return a
      // new iterator, we must instead track the items we want to erase, and
      // erase tham *after* the fact.
      list<string> to_erase;
      for (set<string>::const_iterator sit = orphans.begin();
           sit != orphans.end(); ++sit) {
        if (sit->find('_') == sit->find(dom) &&
            symbol_is_global(*it) == symbol_is_global(*sit) &&
            is_first_class(*sit)) {
          format("member_of_domain(`SYM, `DOM);\n",
                 "`SYM", sit->c_str(), "`DOM", it->c_str(), NULL);
          to_erase.push_back(*sit);
        }
      }

      for (list<string>::const_iterator it = to_erase.begin();
           it != to_erase.end(); ++it)
        orphans.erase(*it);
    }
  }
}

static void method_membership(void) {
  set<string> orphans(symbols_processed);
  // As with domain_membership, run in reverse order to get nested classes
  // first
  for (set<string>::reverse_iterator it = symbols_processed.rbegin();
       it != symbols_processed.rend(); ++it) {
    if (symbol_is_global(*it) == global_mode && symbol_get_type(*it) == "c") {
      string prefix(string("$h_") + symbol_base_name(*it) + "_");
      if (symbol_is_global(*it))
        prefix = string("$") + prefix;

      list<string> to_erase;
      for (set<string>::const_iterator sit = orphans.begin();
           sit != orphans.end(); ++sit) {
        if (0 == sit->find(prefix)) {
          string method(sit->substr(prefix.size()));
          string hook(string("$$H_") + method);
          string identity(change_symbol_type_char(*sit, 'u'));
          string constr(change_symbol_type_char(*it, 'h'));
          process_symbol(hook);
          process_symbol(identity);
          format("static void _setup_`SYM(void) {                           \n"
                 "  implant(`HOOK);                                         \n"
                 "  `HOOK = &`SYM;                                          \n"
                 "}                                                         \n"
                 "ATSTART(ANONYMOUS_SLC,ADVICE_INSTALLATION_PRIORITY) {     \n"
                 "  add_hook(&`CONSTR, HOOK_BEFORE, `ID, $$u_method_setup,  \n"
                 "           _setup_`SYM,                                   \n"
                 "           constraint_after_superconstructor);            \n"
                 "} \n",
                 "`HOOK", hook.c_str(), "`ID", identity.c_str(),
                 "`SYM", (*sit).c_str(), "`CONSTR", constr.c_str(), NULL);
        }
      }

      for (list<string>::const_iterator it = to_erase.begin();
           it != to_erase.end(); ++it)
        orphans.erase(*it);
    }
  }
}
