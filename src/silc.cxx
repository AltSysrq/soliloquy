/*
  Copyright â“’ 2012, 2013 Jason Lingle

  This file is part of Soliloquy.

  Soliloquy is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  Soliloquy is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with Soliloquy.  If not, see <http://www.gnu.org/licenses/>.
*/
#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

/*
  This is the Silc code generator for Soliloquy symbols. It is only intended to
  be used implicitly by the Makefile.

  If given a file basename on the command-line, it operates in local mode,
  reading from FILE.c and writing to FILE.slc. If given more than one, it
  operates in global mode, reading all listed files (*with* their extensions)
  and writing to symbols.def.
*/

#include <string>
#include <iostream>
#include <fstream>
#include <cstring>
#include <cstdlib>
#include <set>
#include <vector>
#include <cstdarg>
#include <cerrno>
#include <cctype>
#include <list>
#include <map>
using namespace std;

static set<string> symbols_processed, symbols_known, templates_instantiated;
static ofstream out;

static string current_file;
static unsigned line_number;

static int exit_status = 0;

static void process_file(const string&);
static void process_symbol(const string&);
static void read_external_classes(void);
static void domain_membership(void);
static void method_membership(void);
int main(int argc, const char*const* argv) {
  string basename = argv[1];
  out.open((basename + ".slc").c_str());
  if (!out) {
    perror("ofstream");
    return 1;
  }

  out << "/**\n * Autogenerated by silc.\n * Do not edit.\n"
      << " * Not intended for human consumption.\n */\n"
      << "#include <common.h>\n";
  // Quick-and-dirty test-for-existence in C++03
  if (ifstream((basename + ".h").c_str()))
    out << "#include \"" << basename << ".h\"\n";

  process_symbol("$u_fundamental_construction");
  process_file(basename + ".c");

  // Some implicit symbols
  current_file="<<IMPLICIT>>";
  line_number=0;
  process_symbol("$u_superconstructor");
  process_symbol("$u_method_setup");
  process_symbol("$u_main");

  //Post-processing tasks dealing with inter-symbol relations
  read_external_classes();
  method_membership();
  domain_membership();

  out << "#undef ANONYMOUS" << endl
      << "#define ANONYMOUS _GLUE(_anon2_,__LINE__)" << endl;

  return exit_status;
}

static void process_line(const string&);
static void process_file(const string& infile) {
  ifstream in(infile.c_str());
  if (!in) {
    perror("ifstream");
    exit(1);
  }

  current_file = infile;
  line_number = 0;

  string line;
  while (getline(in, line)) {
    ++line_number;
    process_line(line);
  }
}

static void process_symbol_starting_at(unsigned&, const string&);
static void process_line(const string& line) {
  for (unsigned i = 0; i+4 <= line.size(); ++i) {
    if (line[i] == '$' &&
        (isalnum(line[i+1]) ||
         (line[i+1] == '$' && isalnum(line[i+2])))) {
      process_symbol_starting_at(i, line);
      --i;
    }
  }
}

static void process_symbol(const string&);
static void process_symbol_starting_at(unsigned& ix, const string& line) {
  unsigned begin = ix;

  // Init state: We already know there is a $ at the beginning
  ++ix;
  // Possible second dollar
  if (line[ix] == '$') ++ix;
  // Type (alnum), should have been verified to be at least one by caller
  do { ++ix; } while (ix < line.size() && isalnum(line[ix]));

  // Underscore after type
  if (ix >= line.size() || line[ix] != '_') {
    cerr << current_file << ':' << line_number << ':'
         << ix << "--" << ix << ": Invalid symbol name (forgot type?)"
         << endl;
    exit_status = 1;
    return;
  }
  ++ix;
  // At least one character basename
  if (ix >= line.size() || !isalnum(line[ix])) {
    cerr << current_file << ':' << line_number << ':'
         << ix << "--" << ix << ": Symbol names must begin with alphanumeric"
         << endl;
    return;
  }

  // Don't care about the rest of the symbol
  while (ix < line.size() && (isalnum(line[ix]) || line[ix] == '_'))
    ++ix;

  process_symbol(line.substr(begin, ix-begin));
}

static bool symbol_is_global(const string& sym) {
  return sym[1] != '$';
}

static string symbol_get_type(const string& sym) {
  unsigned start = symbol_is_global(sym)? 1 : 2;
  return sym.substr(start, sym.find('_')-start);
}

static bool is_first_class(const string& sym) {
  string type(symbol_get_type(sym));
  return
    type != "F" && type != "M" && type != "c" &&
    type != "d" && type != "f" && type != "m" &&
    type != "u";
}

static string symbol_base_name(const string& sym) {
  return sym.substr(sym.find('_')+1);
}

// Extern since there's no way to predeclare a static variable
extern const map<char, void (*)(const string&)> symbol_processors;

static void process_symbol(const string& sym) {
  // Do nothing if we already handled this symbol
  if (symbols_processed.count(sym))
    return;
  symbols_processed.insert(sym);
  
  string type(symbol_get_type(sym));
  map<char, void (*)(const string&)>::const_iterator it =
    symbol_processors.find(type[0]);

  if (it == symbol_processors.end()) {
    cerr << current_file << ':' << line_number
         << ": Unknown symbol type: " << type
         << ", in symbol: " << sym << endl;
    exit_status = 1;
    return;
  }

  it->second(sym);
}

static void process_first_class(const string&);
static void process_function_macro(const string&);
static void process_class(const string&);
static void process_symbol_domain(const string&);
static void process_function(const string&);
static void process_unique_identity(const string&);

#define p(x,y) pair<char, void (*)(const string&)>(x,y)
static const pair<char, void (*)(const string&)> symbol_processors_[] = {
  p('F', process_function_macro),
  p('H', process_first_class),
  p('I', process_first_class),
  p('M', process_function_macro),
  p('Q', process_first_class),
  p('S', process_first_class),
  p('W', process_first_class),
  p('a', process_first_class),
  p('c', process_class),
  p('d', process_symbol_domain),
  p('f', process_function),
  p('h', process_first_class),
  p('i', process_first_class),
  p('l', process_first_class),
  p('m', process_function),
  p('o', process_first_class),
  p('p', process_first_class),
  p('q', process_first_class),
  p('s', process_first_class),
  p('u', process_unique_identity),
  p('v', process_first_class),
  p('w', process_first_class),
  p('x', process_first_class),
  p('y', process_first_class),
  p('z', process_first_class),
};
const map<char, void (*)(const string&)> symbol_processors(
  symbol_processors_,
  symbol_processors_ + sizeof(symbol_processors_)/sizeof(symbol_processors_[0])
);

static bool get_ctype_of_type(string&,
                              const string& symbol, const string& type);
static bool instantiate_templates(const string& symbol, const string& type);
static string change_symbol_type_char(const string& symbol, char newtype);
static void linkage_of(const char*& extern_, const char*& attr,
                       const string& symbol);

static void format(const string& templait, ...);

static void process_first_class(const string& symbol) {
  string type(symbol_get_type(symbol));
  string ctype;
  if (!get_ctype_of_type(ctype, symbol, type)) return;
  if (!instantiate_templates(symbol, type)) return;

  const char* ext, * attr;
  linkage_of(ext, attr, symbol);

  format("`EXTERN struct symbol_header `ATTR _`SYM$base;                \n"
         "`EXTERN typeof(`CTYPE) `ATTR _`SYM;                           \n"
         "ATSTARTA(_init_`SYM, SYMBOL_CONSTRUCTION_PRIORITY,`EXTERN,`ATTR) {\n"
         "  _`SYM$base.size = sizeof(`CTYPE);                           \n"
         "  _`SYM$base.payload = &_`SYM;                                \n"
         "}                                                             \n"
         "ATSTARTA(_ri_`SYM, SYMBOL_ROOT_IMPLANTATION_PRIORITY,`EXTERN,`ATTR){\n"
         "  object_implant(&_`SYM$base, ImplantSingle);                 \n"
         "}                                                             \n"
         "static const enum implantation_type                           \n"
         "    _`SYM$implantation_type = ImplantSingle;                  \n"
         "#define `SYM _`SYM                                            \n",
         "`EXTERN", ext, "`ATTR", attr, "`SYM", symbol.c_str(),
         "`CTYPE", ctype.c_str(), NULL);
}

static void process_function_macro(const string& symF) {
  string symf;
  string type(symbol_get_type(symF));
  if (type == "F") {
    symf = change_symbol_type_char(symF, 'f');
  } else {
    symf = change_symbol_type_char(symF, 'm');
  }
  process_symbol(symf);

  format("#define `SYMF(ret, this, ...) ({\\\n"
         "  typeof(ret) _`SYMF$local_ret; \\\n"
         "  within_context(this, ({       \\\n"
         "    (void)({__VA_ARGS__; 0;});  \\\n"
         "    `SYMf();                    \\\n"
         "    _`SYMF$local_ret = (ret);   \\\n"
         "  }));                          \\\n"
         "  _`SYMF$local_ret;             \\\n"
         "})                                \n",
         "`SYMF", symF.c_str(), "`SYMf", symf.c_str(), NULL);
}

static void process_class(const string& csym) {
  string fsym, osym, usym, dsym, hsym;
  fsym = change_symbol_type_char(csym, 'f');
  osym = change_symbol_type_char(csym, 'o');
  usym = change_symbol_type_char(csym, 'u');
  dsym = change_symbol_type_char(csym, 'd');
  hsym = change_symbol_type_char(csym, 'h');
  process_symbol(fsym);
  process_symbol(osym);
  process_symbol(usym);
  process_symbol(dsym);
  process_symbol(hsym);
  format("#define `CSYM(...) ({                                          \\\n"
         "  object _`CSYM$local_this = object_new(NULL);                 \\\n"
         "  $$(_`CSYM$local_this) {                                      \\\n"
         //This is redundant with the fundamental constructor, but is necessary
         //to get the expected results when calling via the $c frontend.
         "    implant(`OSYM); implant(`DSYM); implant(`HSYM);            \\\n"
         "    `OSYM = _`CSYM$local_this;                                 \\\n"
         "    (void)({__VA_ARGS__; 0;});                                 \\\n"
         "    `FSYM();                                                   \\\n"
         "  }                                                            \\\n"
         "  _`CSYM$local_this; })                                          \n"
         "#define `CSYM$domain `DSYM                                       \n"
         "#define `CSYM$function `FSYM                                     \n"
         "#define `CSYM$identity `USYM                                     \n"
         "#define `CSYM$hook `HSYM                                         \n"
         "#define `CSYM$this `OSYM                                         \n"
         "static void _`CSYM$fun_ctor(void) {                              \n"
         "  implant(`OSYM); implant(`DSYM); implant(`HSYM);                \n"
         "  `OSYM = object_current();                                      \n"
         "}                                                                \n"
         "ATSTART(ANONYMOUS, ADVICE_INSTALLATION_PRIORITY) {               \n"
         "  add_hook(&`HSYM, HOOK_BEFORE,                                  \n"
         "           $u_fundamental_construction, `USYM,                   \n"
         "           _`CSYM$fun_ctor,constraint_before_superconstructor);  \n"
         "}                                                                \n",
         "`CSYM", csym.c_str(), "`OSYM", osym.c_str(),
         "`USYM", usym.c_str(), "`DSYM", dsym.c_str(),
         "`HSYM", hsym.c_str(), "`FSYM", fsym.c_str(), NULL);
}

static void process_function(const string& sym) {
  string hsym(change_symbol_type_char(sym,
                                      symbol_get_type(sym) == "f"?
                                      'h' : 'H'));
  process_symbol(hsym);
  const char* ext, * attr;
  linkage_of(ext, attr, sym);
  format("`EXTERN void _`SYM(void) `ATTR;            \n"
         "`EXTERN void _`SYM(void) {                 \n"
         "  invoke_hook(`REF`HOOK);                  \n"
         "}                                          \n"
         "#define `SYM _`SYM                         \n",
         "`EXTERN", ext, "`ATTR", attr, "`SYM", sym.c_str(),
         "`REF", (symbol_get_type(sym) == "f"? "&" : ""),
         "`HOOK", hsym.c_str(),
         NULL);
}

static void process_unique_identity(const string& sym) {
  const char* ext, * attr;
  linkage_of(ext, attr, sym);
  format("`EXTERN const identity `ATTR _`SYM = (identity)&_`SYM;\n",
         "`EXTERN", ext, "`ATTR", attr, "`SYM", sym.c_str(), NULL);

  format("#define `SYM _`SYM\n",
         "`SYM", sym.c_str(), NULL);
}

static void process_symbol_domain(const string& sym) {
  const char* ext, * attr;
  linkage_of(ext, attr, sym);
  format("`EXTERN struct symbol_header `ATTR _`SYM$base;                \n"
         "`EXTERN struct symbol_domain* `ATTR _`SYM = NULL;             \n"
         "ATSTARTA(_init_`SYM, SYMBOL_CONSTRUCTION_PRIORITY,`EXTERN,`ATTR) {    \n"
         "  _`SYM$base.size = sizeof(struct symbol_domain*);            \n"
         "  _`SYM$base.payload = &_`SYM;                                \n"
         "}                                                             \n"
         "static const enum implantation_type _`SYM$implantation_type = \n"
         "    ImplantDomain;                                            \n"
         "#define `SYM _`SYM                                            \n",
         "`EXTERN", ext, "`ATTR", attr, "`SYM", sym.c_str(), NULL);
}

static bool get_ctype_of_type(string& ctype,
                              const string& symbol, const string& type) {
  if (type.empty()) {
    cerr << current_file << ':' << line_number
         << ": Empty type encountered processing symbol: " << symbol << endl
         << current_file << ':' << line_number
         << ": You probably forgot to specify a template type "
         << current_file << ':' << line_number
         << ": (eg, $l_foo is not ok, you must say what is in the list, eg, $ls_foo)"
         << endl;
    exit_status = 1;
    return false;
  }

  switch (type[0]) {
  case 'H':
    ctype = "struct hook_point*";
    break;

  case 'I':
    ctype = "unsigned";
    break;

  case 'Q':
    ctype = "mqstring";
    break;

  case 'S':
    ctype = "mstring";
    break;

  case 'W':
    ctype = "mwstring";
    break;

  case 'a':
    ctype = string("dynar_") + type.substr(1);
    break;

  case 'h':
    ctype = "struct hook_point";
    break;

  case 'i':
    ctype = "signed";
    break;

  case 'l':
    ctype = string("list_") + type.substr(1);
    break;

  case 'o':
    ctype = "object";
    break;

  case 'p':
    ctype = "void*";
    break;

  case 'q':
    ctype = "qstring";
    break;

  case 's':
    ctype = "string";
    break;

  case 'v':
    ctype = "identity";
    break;

  case 'w':
    ctype = "wstring";
    break;

  case 'x':
    ctype = "qchar";
    break;

  case 'y':
    ctype = "bool";
    break;

  case 'z':
    ctype = "wchar_t";
    break;

  default:
    cerr << current_file << ':' << line_number
         << ": Unrecognised or non-first-class type: " << type << endl
         << current_file << ':' << line_number
         << ": While processing symbol: " << symbol << endl;
    return false;
  }

  return true;
}

static bool instantiate_templates(const string& symbol, const string& type) {
  if (type.empty()) return true;
  if (templates_instantiated.count(type)) return true;
  templates_instantiated.insert(type);

  static bool has_loaded = false;
  static string list_template, dynar_template;
  if (!has_loaded) {
    has_loaded = true;
    {
      ifstream in("list.plt");
      if (!in) {
        perror("ifstream(list.plt)");
        exit(255);
      }

      getline(in, list_template, '\0');
    }

    {
      ifstream in("dynar.plt");
      if (!in) {
        perror("ifstream(dynar.plt)");
        exit(255);
      }

      getline(in, dynar_template, '\0');
    }
  }

  string sub = type.substr(1);

  if (type[0] == 'l' || type[0] == 'a') {
    string ctype;
    if (!get_ctype_of_type(ctype, symbol, sub)) return false;
    if (!instantiate_templates(symbol, sub)) return false;

    format(type[0] == 'l'? list_template : dynar_template,
           "CTYPE", ctype.c_str(), "HUNG", sub.c_str(), NULL);
  }

  return true;
}

static string change_symbol_type_char(const string& symbol, char type) {
  string ret(symbol);
  ret[symbol_is_global(ret)? 1 : 2] = type;
  return ret;
}

static void linkage_of(const char*& ext, const char*& attr,
                       const string& symbol) {
  if (symbol_is_global(symbol)) {
    ext = "";
    attr = "__attribute__((weak))";
  } else {
    ext = "static";
    attr = "";
  }
}

static void format(const string& templait, ...) {
  string output(templait);
  
  va_list args;
  va_start(args, templait);

  const char* from, * to;
  while ((from = va_arg(args, const char*))) {
    to = va_arg(args, const char*);

    size_t where;
    while (string::npos != (where = output.find(from)))
      output.replace(where, strlen(from), to);
  }
  
  va_end(args);

  out << output;
}

static void domain_membership(void) {
  set<string> orphans(symbols_processed);
  // Iterate through the processed symbols in reverse order (longer, more
  // specific domains will come first).
  for (set<string>::reverse_iterator it = symbols_known.rbegin();
       it != symbols_known.rend(); ++it) {
    if (symbol_get_type(*it) == "d") {
      string dom(string("_") + symbol_base_name(*it) + "_");
      // Since for some reason the C++03 API doesn't have set::erase() return a
      // new iterator, we must instead track the items we want to erase, and
      // erase tham *after* the fact.
      list<string> to_erase;
      for (set<string>::const_iterator sit = orphans.begin();
           sit != orphans.end(); ++sit) {
        if (sit->find('_') == sit->find(dom) &&
            symbol_is_global(*it) == symbol_is_global(*sit) &&
            is_first_class(*sit)) {
          process_symbol(*it);
          format("member_of_domain(`SYM, `DOM);\n",
                 "`SYM", sit->c_str(), "`DOM", it->c_str(), NULL);
          to_erase.push_back(*sit);
        }
      }

      for (list<string>::const_iterator it = to_erase.begin();
           it != to_erase.end(); ++it)
        orphans.erase(*it);
    }
  }
}

static void method_membership(void) {
  set<string> orphans(symbols_processed);
  // As with domain_membership, run in reverse order to get nested classes
  // first
  for (set<string>::reverse_iterator it = symbols_known.rbegin();
       it != symbols_known.rend(); ++it) {
    if (symbol_get_type(*it) == "c") {
      string prefix(string("$h_") + symbol_base_name(*it) + "_");
      if (!symbol_is_global(*it))
        prefix = string("$") + prefix;

      list<string> to_erase;
      for (set<string>::const_iterator sit = orphans.begin();
           sit != orphans.end(); ++sit) {
        if (0 == sit->find(prefix)) {
          string method(sit->substr(prefix.size()));
          string hook(string("$H_") + method);
          string identity(change_symbol_type_char(*sit, 'u'));
          string constr(change_symbol_type_char(*it, 'h'));
          process_symbol(hook);
          process_symbol(identity);
          process_symbol(constr);
          const char* ext, * attr;
          linkage_of(ext, attr, *sit);
          format("static void _setup_`SYM(void) {                           \n"
                 "  implant(`HOOK);                                         \n"
                 "  `HOOK = &`SYM;                                          \n"
                 "}                                                         \n"
                 "ATSTARTA(_ia_`SYM,ADVICE_INSTALLATION_PRIORITY,`EXTERN,`ATTR) {\n"
                 "  add_hook(&`CONSTR, HOOK_BEFORE, `ID, $u_method_setup,   \n"
                 "           _setup_`SYM,                                   \n"
                 "           constraint_after_superconstructor);            \n"
                 "} \n",
                 "`HOOK", hook.c_str(), "`ID", identity.c_str(),
                 "`SYM", (*sit).c_str(), "`CONSTR", constr.c_str(),
                 "`EXTERN", ext, "`ATTR", attr, NULL);
        }
      }

      for (list<string>::const_iterator it = to_erase.begin();
           it != to_erase.end(); ++it)
        orphans.erase(*it);
    }
  }
}

void read_external_classes(void) {
  symbols_known = symbols_processed;
  /* Read all classes from the "classes" file, and add them to processesd
   * symbols so that classes mentioned in other files will be handled
   * correctly (ie, implantation).
   */
  ifstream in("classes");
  string clazz;
  while (getline(in, clazz, '\n'))
    symbols_known.insert(clazz);
}
