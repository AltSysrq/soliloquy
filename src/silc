#! /bin/sh

LC_ALL=C
export LC_ALL

extract_types() {
    while read sym; do
        echo "$sym" | grep -E -o '[a-zA-Z0-9]+' | head -n 1
    done
}

extract_templates_from_symbols() {
    extract_types | (while read type; do
        while echo $type | grep -q -E '^[la]'; do
            # By padding names to the left with spaces, we ensure that nested
            # types are instantiated in the correct order (ie, lp before llp).
            # Hopefully nobody needs more than 100th-order lists or arrays.
            printf '%100s\n' "$type"

            # Trim the leading generic off
            type=`echo $type | sed 's/^.//'`
        done
    done)
}

instantiate_templates() {
    while read type; do
        if echo $type | grep -q -E '^l'; then
            # List
            TEMPLATE=list.m4
        else
            TEMPLATE=dynar.m4
        fi
        subtype=`echo $type | sed 's/^.//'`
        if ctype=`get_ctype_of_hung $subtype`; then
            m4 -DHUNG=$subtype -DCTYPE=$ctype $TEMPLATE
        else
            echo "While instantiating template for type: $type" >&2
            echo "  (Look for a symbol beginning with \$${type}_ or \$\$${type}_)" >&2
            exit 1
        fi
    done
}

add_implicit_symbols() {
    while read sym; do
        # $f needs implicit $h
        if echo $sym | grep -q -E '\$f'; then
            echo $sym | sed 's/$f/$h/'
        elif echo $sym | grep -q -E '\$c'; then
            echo $sym | sed 's/$c/$d/'
            echo $sym | sed 's/$c/$f/'
            echo $sym | sed 's/$c/$h/'
            echo $sym | sed 's/$c/$u/'
            echo $sym | sed 's/$c/$o/'
        elif echo $sym | grep -q -E '\$F'; then
            echo $sym | sed 's/$F/$f/'
            echo $sym | sed 's/$F/$h/'
        fi
        echo $sym
    done
}

get_ctype_of_hung() {
    subtype=`echo $1 | sed 's/^.//'`
    case $1 in
        a*)
            echo dynar_$subtype
            ;;
        l*)
            echo list_$subtype
            ;;
        i)
            echo int
            ;;
        s)
            echo string
            ;;
        h)
            echo 'struct hook_point'
            ;;
        v)
            echo identity
            ;;
        p)
            echo 'void*'
            ;;
        o)
            echo object
            ;;
        *)
            echo "Invalid symbol type, or a non-first-class type in a generic context: $1" >&2
            exit 1
    esac
}

declare_symbols() {
    while read symbol; do
        type=`echo $symbol | extract_types`
        case $type in
            f)
                echo "extern void _$symbol(void);"
                ;;
            u)
                echo "extern const identity _$symbol;"
                ;;
            d)
                echo "extern struct symbol_domain* _$symbol;"
                echo "extern struct symbol_header _${symbol}_base;"
                echo "static const enum implantation_type _${symbol}_implantation_type = ImplantDomain;"
                ;;
            c)
                define_c_symbol "$symbol"
                ;;
            F)
                define_F_symbol "$symbol"
                ;;
            *)
                if ctype=`get_ctype_of_hung $type`; then
                    echo "extern struct symbol_header _${symbol}_base;"
                    echo "extern typeof($ctype) _$symbol;"
                    echo "static const enum implantation_type _${symbol}_implantation_type = ImplantSingle;"
                else
                    echo "While processing symbol: $symbol" >&2
                    exit 1
                fi
        esac

        if test "$type" != c && test "$type" != F; then
            echo "#define $symbol _$symbol"
        fi
    done
}

define_symbols() {
    define_implantation_types="$1"
    while read symbol; do
        if echo "$symbol" | grep -qF '$$'; then
            linkage=''
        else
            linkage='static'
        fi
        type=`echo $symbol | extract_types`
        case $type in
            f)
                hook_name=`echo $symbol | sed 's/$f/$h/'`
                echo "$linkage void _$symbol(void) {"
                echo "invoke_hook(&$hook_name);"
                echo "}"
                ;;
            u)
                echo "$linkage const identity _$symbol = (identity)&_$symbol;"
                ;;
            d)
                echo "$linkage struct symbol_header _${symbol}_base;"
                echo "$linkage struct symbol_domain* _$symbol = NULL;"
                echo "ATSTART(ANONYMOUS, SYMBOL_CONSTRUCTION_PRIORITY) {"
                echo "_${symbol}_base.size = sizeof(struct symbol_domain*);"
                echo "_${symbol}_base.payload = &_$symbol;"
                echo "}"
                if test "x$define_implantation_types" = "xyes"; then
                    echo "static const enum implantation_type _${symbol}_implantation_type = ImplantDomain;"
                fi
                ;;
            c)
                define_c_symbol "$symbol"
                ;;
            F)
                define_F_symbol "$symbol"
                ;;
            *)
                if ctype=`get_ctype_of_hung $type`; then
                    echo "$linkage struct symbol_header _${symbol}_base;"
                    echo "$linkage typeof($ctype) _$symbol;"
                    echo "ATSTART(ANONYMOUS, SYMBOL_CONSTRUCTION_PRIORITY) {"
                    echo "_${symbol}_base.size = sizeof($ctype);"
                    echo "_${symbol}_base.payload = &_$symbol;"
                    echo "}"
                    if test "x$define_implantation_types" = "xyes"; then
                        echo "static const enum implantation_type _${symbol}_implantation_type = ImplantSingle;"
                    fi
                    echo "ATSTART(ANONYMOUS, SYMBOL_ROOT_IMPLANTATION_PRIORITY) {"
                    echo "object_implant(&_${symbol}_base, ImplantSingle);"
                    echo "}"
                else
                    echo "While processing symbol: $symbol" >&2
                    exit 1
                fi
        esac

        if test "$type" != c && test "$type" != F; then
            echo "#define $symbol _$symbol"
        fi
    done
}

define_c_symbol() {
    csym=$1
    fsym=`echo $csym | sed 's/$c/$f/'`
    osym=`echo $csym | sed 's/$c/$o/'`
    usym=`echo $csym | sed 's/$c/$u/'`
    dsym=`echo $csym | sed 's/$c/$d/'`
    hsym=`echo $csym | sed 's/$c/$h/'`
    echo "#define ${csym}(...) ({\\"
    echo "  object _csym_this = object_new(NULL); \\"
    echo "  within_context(_csym_this, {\\"
    echo "    implant($osym); implant($dsym); implant($hsym); \\"
    echo "    $osym = _csym_this; \\"
    echo "    __VA_ARGS__; \\"
    echo "    ${fsym}(); \\"
    echo "  }); \\"
    echo "  _csym_this; })"
    echo "#define ${csym}_domain $dsym"
    echo "#define ${csym}_function $fsym"
    echo "#define ${csym}_identity $usym"
}

define_F_symbol() {
    Fsym=$1
    fsym=`echo $Fsym | sed 's/$F/$f/'`
    echo "#define ${Fsym}(ret, this, ...) ({\\"
    echo "  typeof(ret) _Fsym_ret;\\"
    echo "  within_context((this), {\\"
    echo "    __VA_ARGS__; \\"
    echo "    ${fsym}();\\"
    echo "    _Fsym_ret = (ret);\\"
    echo "  }); \\"
    echo "  _Fsym_ret; })"
}

domain_membership() {
    INFILE=$1.1
    TMPFILE=$1.2
    <$1 grep -v -E '\$[cFfu]' >$INFILE

    while read domain; do
        # Get the base name out of the domain
        basename=`echo $domain | sed 's/$*[a-zA-Z]*_//'`
        # Add direct members of this domain
        <$INFILE grep -E "^\\$+[a-zA-Z]+_${basename}_" | (while read sym; do
            echo "member_of_domain($sym, $domain)"
        done)
        # Remove direct members from symbols list
        <$INFILE grep -vE "^\$$+[a-zA-Z]+_${basename}_" >$TMPFILE
        mv $TMPFILE $INFILE
    done
        
    rm -f $INFILE $TMPFILE
}

if test -z "$1"; then
    # Global symbols
    OUTFILE=symbols.def
    rm -f $OUTFILE
    # Symbol sorting must be reversed, since $f depends on $h (and there are no
    # other interdependencies).
    find . -name '*.c' -exec grep -E -o '\$\$[a-zA-Z0-9_]+' '{}' \; \
        | add_implicit_symbols | sort -ru >symbols.list
    <symbols.list extract_templates_from_symbols | sort -u | \
        instantiate_templates >$OUTFILE || exit $?
    <symbols.list define_symbols no >>$OUTFILE || exit $?
    <symbols.list grep -F '$$d' | sort -r | domain_membership symbols.list >>$OUTFILE || exit $?
    rm symbols.list
else
    # Symbols local to a compilation unit
    OUTFILE=$1.slc
    >$OUTFILE cat <<EOF
/**
 * Auto-generated by silc. Do not edit. Not intended for human consumption.
 */
#include <common.h>
EOF
    test -f $1.h && echo "#include \"$1.h\"" >>$OUTFILE
    grep -E -o '\$\$?[a-zA-Z0-9_]+' $1.c \
        | add_implicit_symbols | sort -ru >$1.list
    cat implicit_symbols >>$1.list
    <$1.list extract_templates_from_symbols | sort -u | \
        instantiate_templates >>$OUTFILE || exit $?
    <$1.list grep -F '$$' | declare_symbols >>$OUTFILE || exit $?
    <$1.list grep -F -v '$$' | define_symbols yes >>$OUTFILE || exit $?
    <$1.list grep -E '^\$d' | sort -r | domain_membership $1.list >>$OUTFILE || exit $?
    rm $1.list
fi
